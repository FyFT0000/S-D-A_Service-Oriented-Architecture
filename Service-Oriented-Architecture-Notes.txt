https://www.coursera.org/learn/service-oriented-architecture?specialization=software-design-architecture

Service-Oriented Architecture
    Based on an understanding of architectural styles, you will review architectures for web applications, then explore the basics of Service-Oriented Architecture (SOA) in two approaches: Web Services (WS*) and Representational State Transfer (REST) architecture. 



4.1.1 – Introduction to Service-Oriented Architecture
A service is external to the software requesting it, and often remove – either in another service in the company or somewhere on the internet. Services are often associated with two roles:
    _1. the service requester, which is the software requesting the service.
    _2. the service provider, which fulfills requests.
 These roles echo client and server roles in similar domains, so sometimes these terms are used interchangeably.
 _   Service-Oriented Architecture (SOA): examines how to build, use, and combine services. Instead of creating large software suites that do everything, service-oriented architecture reaches software goals by building and using services, and designing an architecture that supports their use. This course will cover software-oriented architecture in two contexts:
    _1. on the Internet (also known as “external” to an organization)
    _2. in large organizations (also known as “internal” to the organization)
_   Web Services: are services that are offered on the Internet. It is possible to build feature-full apps on the Internet by using existing web services external to your application to fulfill some of the tasks. For instance, a web application for travelling may take advantage of services that obtain flight prices on the internet, services that obtain hotel prices, or car rental services. Essentially, a number of services only had to be combined to create an application.
    _Web services may entail trade-offs. The ease of using existing services must be balanced against qualities of the services, which is not under the control of developers. In these cases, non-functional requirements become very important. These might include:  Response Time  Supportability  Availability, of the service, as determined by outside parties.
_   Large Organizations or enterprises: code that is built in-house can be turned into services. In turn, these services can be used by different parts of the business, or by adding interfaces to existing software. These services can then be used to drive business or organizational goals. For example, a company might offer an interface for software systems in various departments to request information about support costs in their software. Support costs are offered as a service that departments can query.
    _Internal service-oriented architecture encourages organizations to build general, reusable software services that can be used and combined as needed. This architecture allows businesses to respond to opportunities quickly, and makes services easier to access for new business units.
    _Developing an extensive service-oriented architecture (SOA) can present trade-offs for large organizations. A full switch to SOA is costly, and it can be difficult to support despite its benefits. In these cases, services are often introduced bit by bit, separating out the most useful, cross-departmental functions first.
    _Like any other architecture, SOA requires trade-offs and design decisions in implementation, whether it is through web services or in-house organizational services. Additionally, SOA is not easy. Once in place, however, SOAs are powerful, as they provide modularity, extensibility, and code reuse. Applications can be built through combining services. New services can be created by combining existing services, either from the ground up, or through the addition of interfaces to existing code.

4.1.2 – Service Principles
In order to create useful and reusable services, and by extension, service-oriented architecture (SOA), there are certain best practices, guidelines, and principles that have been developed that outline the desired properties that services should have. These desired properties for services are outlined in the table below.
_   Modular and Loosely Coupled: Services should be module and loosely coupled. This allows services to be reusable and combinable – in other words, services can be mixed and matched if they are modular. In object-oriented programming, loose coupling is achieved by exposing only the relevant elements of a class or component to its client. In SOA, requests are made by passing communication to the service in a way that aligns with its interface. The service performs the necessary operations and then passes back a communication containing the result of the service or a confirmation that the request was fulfilled.
_   Composable: Services should be used in combination, in order to create usable applications or other services. In order to achieve this property, services should be modular. Just like objects can be combined in object-oriented programming to provide the desired behaviour, services should be able to combined to provide a desired end- goal in SOA.
_   Platform- and Language- Independent: Services should be platform independent and language independent. For example, a service coded in Java can be used by a service requester coded in Ruby. To achieve platform- and language- independence, communication standards and protocols must be followed. For example, services on the Internet are often requested with an XML file or HTTP request.
_   Self-Describing: A service should describe how to interact with it. In other words, a service should describe its own interfaces. This includes what input the service takes, and what output the service gives. There are formal standards for describing services, including web service description language (WSDL).
_   Self-Advertising: Services must make known to potential clients that it is available. In-house organizations may create service catalogues, while distributed applications using web services have standards like Universal Description, Discovery, and Integration (UDDI) to connect service providers with potential service requesters.

4.1.3 - Web Systems Evolution
Often, the terms “Internet” and “World Wide Web” are used interchangeable. However, these terms actually refer to two different, but interrelated things. The Internet was actually invented almost 20 years before the World Wide Web!
_   In 1969, a small computer network called ARPANET was created and used by researchers in the United States, in order to send a small amount of data between pairs of computers. This was the first-time data was sent across a computer network. In the following years, small networks were developed at research institutions across the United States. Further, these networks began to connect with each other. Once this network of networks reached a global scale, the Internet was born.
_   The World Wide Web, otherwise known as “the web” led to standards and technologies for computer-based communication over the Internet. Web standards include Hypertext Markup Language (HTML), and Hypertext Transport Protocol (HTTP). The introduction of HTML and web browsers in the early 1990s, which allowed users to view websites, greatly increased the popularity of the web.
_   Websites are made up of web pages. To view a web page, the web browser makes a request to the web server that hosts the web page, then the web server handles the request by returning the HTML document that corresponds to the requested web page, and then the browser renders this HTML document to the user. The relationship between web browser and web service is a client-server relationship. Both the request and the response are messages conveyed in HTTP, a communication protocol that both the web browser and web server understand.
_   Static Web Pages: Initially, the web consisted of static web pages, which were web pages stored on the server as a separate HTML file. When a static web page is viewed on a web browser, the HTML rendered on the screen is the same HTML document stored on the web server. The document on the web server has not changed or been customized before being served to the client. In order to change the web page, the corresponding HTML document must be changed. Under this model, even small changes to a web page may require the update of many HTML documents to maintain consistency across the whole website. Since changes require manual developer intervention, static websites are best used for presenting information that does not change very often, like personal websites or publications.
_   Dynamic Web Pages: Beginning in 1993, dynamic web pages began to emerge in response to the lack of customizability and scalability imposed by static web pages. Dynamic web pages are generated at the time of access. This means that the web page does not exist on a server before it is generated. When a dynamic web page is viewed, the web server passes on the request to an application to handle. The application can perform a computation, lookup some information in a database, or request information from a web service, which produces dynamic content as output. The application can generate an HTML document for the server, and then the server sends that back to the web browser, which can then display it for a user.
    _Making changes to dynamic websites is much easier than for static web pages. Changes need only be applied to one database element or variable in the application to make a change throughout a dynamic website.
    _Dynamic web pages provide many advantages. They can be customized for the view, they can respond to external events, they generally provide increased functionality compared to their static counterparts, and they are easier for a developer to modify. Currently, dynamic web pages dominate the web, including many types of webpages such as personal blogs and news feeds.
    _Although it is not always easy to determine if a website is statically or dynamically generated, a good rule of thumb is that more complex websites tend to be dynamic. Static webpages are still excellent tools to use for web pages whose content does not need to be personalized or does not change often.
_   Web Applications: A growing trend in web-based systems is the use of web-based applications, otherwise known as web applications. Web applications, like desktop applications, provide graphical user interfaces that allow users to interact with them, but a web application is run in a web browser and is stored on a remote web server, whereas a desktop application is run and stored locally on a computer.
    _Web applications are platform independent. This means that they can run on any operating system, provided that a compatible web browser is installed. Web applications eliminate the need for users to download and maintain application software on a computer. However, web applications also require users to have Internet access, because web applications communicate information through HTTP with a web server and/or application server on the backend.
    _Web applications provide users with a richer, more interactive web experience than simpler dynamic or static web pages. Web applications enable everything from online banking, online learning, online games, calculators, calendars, and more.
_   Web Services: If web applications or websites integrate with web services, real-time information can be used to create more complex, richer applications. Web services, in turn, can rely on other services. Web services can be used to satisfy specific needs, such as stock market data, weather reports, or currency conversion.
    _By treating web services like reusable components, information produced by these web services can be used by many different web applications at the same time. Web applications and web services communicate over the web using open standards like HTTP, XML, and JSON, which are easy for machines to manipulate.
    _Web services can be accessed through programmatic means, or services provide a user interface that can be embedded in a web page or application. By using web services, request and response of different services is asynchronous. This means that the logic is designed to continue running instead of waiting for a response. A page composed of many services can be generated while the individual services are processing requests and sending responses.

4.1.4 – Web Systems Architecture

Layered: 
In the third course of this specialization, the term layer was defined as a collection of components that work together toward a common purpose. Layers help identify hierarchies in a system. Knowledge of layers helps software designers restrict how layers interact with each other: components in a layer only interact with components in their own layer or adjacent layers, and this may only be done through interfaces provided by each component. Generally, lower layers provide services to layers above them.
_   More complex systems often require more layers to help logically separate components. However, the trade-off to adding more layers is that performance suffers, due to an increase in communication required between layers. Layers are often conceptually organized into presentation, application, and data tiers. In a web-based system, the presentation tier is further divided into two layers: one for the web browser, and one for the web server.
_   Each layer of a web-based system has a function:
    _The web browser layer is the topmost layer of the system. It displays information to the user.
    _The web server layer is directly below the web browser layer. It receives the request from the web browser, obtains the requested content, and returns it to the browser.
    _The application layer is below the web server layer. It is responsible for ensuring the function or service provided by the system is performed.
    _The bottom layer is the data layer. This layer is responsible for storing, maintaining, and managing data. Access to data may be read-only, or may allow for both reading and writing. Depending on the system, this access can be in the form of a filesystem or database.

Layers for Static Web Content:
A static web page has a layered architecture of a web browser layer, a web server layer, and a data layer.
_   The web browser layer typically consists of a web browser, which displays information provided by the web server. The web server layer receives the request from the web browser, and retrieves the appropriate HTML document stored in the data layer. Once the access to the right HTML document is secured, this layer returns the requested content to the browser.
_   The data layer consists of HTML documents that are delivered back to the web browser unchanged by the web server. As HTML documents do not change, the filesystem can be read-only.
_   There is no application layer in a static web content system, as the HTML documents served by the web server are the exact as stored in the file system. No processing has been applied.

Layers for Dynamic Web Content and Web Applications:
In a dynamic web content system, a layered architecture requires a web browser layer, web server layer, application layer, and data layer.
_   As with static web content, the web browser layer typically consists of a web browser, which displays information provided by the web server. Similarly, the web server layer receives the request from the web browser, and returns the requested content to the browser. Unlike a static web page, however, on a dynamic web page, HTML documents are generated when they are requested by a web browser. The web server passes on the request to an application server in the application layer for processing.
_   The application layer for dynamic web pages can consist of one or more programs or applications that process the request to generate the resulting content. The application layer may also call upon other web services, and read and write data to a database via the data layer. This same layering scheme also applies to architectures for complex web applications.

Services View:
An alternative view of the architecture can be considered through a UML component diagram. A web-based system can be thought of as a collection of services and service requester/provider pairings.
_   For example, the database provides data services, and the application server is a server requester to the database. The application server runs programs that may access a variety of web services provided outside the system. Those web services may themselves access other services.
_   Layered architecture and use of outside web services reinforces the basic design principles of separation of concerns and code reuse. Layers have specific responsibilities, while outside services provide functionality that the system does not have to implement. The scope of using web services is huge, so it raises the challenge of identifying the right ones to use.

4.1.5 – HTML / XML / JSON
HTML and XML are markup languages, while JSON is a popular, lightweight data-interchange format used in many web applications today. Markup languages are designed to adorn text in a machine and human readable way, typically to add meaning or structure. Markup languages use tags to mark how certain pieces of text are interpreted. Tags are often standard words that can be defined for some meaning on purpose. 

HTML:
Hypertext Markup Language (HTML) is the markup language used to structure text on web pages. Note that HTML provides structure to web pages, but not styling. For example, HTML marks what parts of the page text are the title, headings, paragraphs, etc., so that they can be rendered appropriately by a web browser. HTML has a predefined set of tags that serve different purposes.
_   The DOCTYPE tag is the first line in any HTML file, and denotes to the browser that the content is HTML. The rest of the document is contained with the <html> tags. In general, HTML documents have two sections: the head and the body. These are contained within the <head> and <body> tags respectively.
_   The head usually contains metadata being used by the page. The body contains the main content and information of the web page. The body contains the text, links, images, lists, and other data to present, all tagged appropriate.
_   Although the structure is tagged, HTML is not meant for styling information. To add aesthetics like fonts and colours, a cascading style sheet (CSS) is applied. CSS references the standard HTML tags to apply specific styles to text within those tags. CSS is applied either via a separate CSS file or directly within the HTML document.

XML:
eXtensible Markup Language (XML) is a markup language meant to store and transport data. XML is both machine and human readable. XML is usually used to send structured data within a web-based system.
_   XML schemas can be defined for the valid tags and their appropriate structure for an XML document.

JSON:
JavaScript Object Notation (JSON) is a format used to store and transport data. It is designed to be both machine and human readable. JSON offers many benefits, because JSON can be easily converted to JavaScript objects, and vice-versa. JavaScript is an interpreted programming language commonly supported in modern web browsers.
_   This ability to easily convert to JavaScript objects and vice-versa makes JSON a popular format when transferring data between web browsers and servers, as well as for passing data around in web applications.
_   JSON data is written as name/value pairs with JSON objects written inside curly braces. JSON data can also have arrays of JSON objects. Arrays in JSON are written inside square brackets.

4.1.6 – HTTP
Hypertext Transfer Protocol (HTTP) is a protocol that dictates how information, including hypertexts, is transferred across the Internet.
_   Hypertext is a document embedded with hyperlinks, which when clicked, will take you to the intended document or resource. Hyperlinks were originally used to link HTML documents. HTTP was designed to facilitate the use of hypertext, and to support the communication of documents and resources expressed in HTML.
_   Over time, hyperlinks have been used to link together multimedia resources, such as images, videos, gifs, text, and audio, or documents containing any combination of these. Resources can be static, such as HTML documents, images, or videos, or dynamic, such as programs that produce some output when they are called.

URIs and URLs
Universal Resource Identifiers (URIs) are addresses used to identify resources. Universal Resource Locators (URLs) are a subset of URIs, that are used to locate resources. Both identify the resource, but URLs also tell the protocol how to locate and access the resource. URLs provide the protocol and domain name or IP address of the machine the resource is stored on, and the location of the resource on the machine. All URLs are URIs, but not all URIs are URLs.
_   The URI does not need to explicitly provide the IP address. The browser is able to resolve the IP address corresponding to the hostname provided in the URI. The browser will either already know the IP address corresponding to the hostname, or if it doesn’t know, it will query a Domain Name System (DNS) server to find out.

TCP
HTTP is built upon a client/server design. To accomplish this, HTTP is built on top of another protocol known as the Transmission Control Protocol (TCP). When a client makes a request to a server, this opens a TCP connection between the client and server allowing for communication. Messages are sent and received through TCP ports. The client/server relationship exists between a web browser and a web server.
_   HTTP relies on TCP connections as they allow for reliable, ordered, connection oriented communication. When a browser accesses a URI that starts with “http”, a connection between the web browser and a web server is opened on TCP port 80. This port is the default for HTTP messages.

HTTP Requests and HTTP Responses
A client request consists of a request-line, headers, a blank line, and sometimes a message body.
    _Request-Line: The request-line includes the request method, request URI and protocol. The URI may end in a query string to specify parameter data for the request, although this is optional. This string is separated from the path of the resource by a question mark.
    _Headers: Client requests may have a various number of headers, of different kinds. Headers may be mandatory or optional. Mandatory headers allow for the request to be processed and optional headers can be used to give context to the request. Two mandatory headers in any request are the host header, which contains the domain name or IP address of the host, and the accept header, which informs the server what kinds of content the client will accept as a response. Further, if a message body is present, then a content-length header that indicates the size of the body in bytes and a content- type header that indicates the type of the body must be included.
    _A Blank Line: A blank line follows headers. If no message body is required for the request, then the request ends here.
    _Message Body: This section contains the message body, if it is required for the request. Message bodies might be HTML documents, JSON, encoded parameters, or other similar content.

Server Response
A server response consists of a status-line, headers, a blank-line, and sometimes, a message body.
    _Status-Line: The request-line includes the protocol version and the HTTP status code. The HTTP status code informs the client of the status of the request. There are many possible HTTP status codes. If the request has been successfully processed, the status code of “200 OK” will likely show.
    _Headers: As with client requests, server responses may have a various number of headers, of different kinds. Headers may be mandatory or optional. Many optional headers exist and can be used to provide more information and context about the communication. If a message body is present, then a content-length header and a content-type header must be included.
    _A Blank Line: A blank line follows headers. If no message body is required for the response, then the response ends here.
    _Message Body: This section contains the message body, if it is required for the response. Message bodies might be HTML documents, JSON, encoded parameters, or other similar content, as with HTTP requests.

Encoding
HTTP limits the characters used in URIs, request queries and request bodies to be ASCII. Special or unsafe characters, like space or Unicode, require the encoding of these characters. An example of an unsafe character is a “space”.
_   Unsafe characters are often replaced with a “%” sign, followed by their two-digit hexadecimal digit encoding. For example, a space can be encoded with “%20”, or with a “+” sign. The phrase “software design and architecture” can thus be encoded either of the following ways:
    _software%20design%20and%20architecture
    _software+design+and+architecture
_   Query strings can also be encoded, using the “=” sign. For example:
    _colour=red
    _height=very+tall
_   The ampersand symbol, “&”, is used to join all the parameter value pairs. For example:
    _colour=red&height=very+tall

GET Method
This lesson has reviewed HTTP requests. Each HTTP request must indicate a request method in its request-line. Request methods are used to indicate to the web server what it should do with the request. The most common request methods are: GET, POST, and PUT.
_   The GET method retrieves the resource given by the URI provided in the request-line. Get methods are used to retrieve web pages, images, or outputs of programs. A query string may be sent along with the request in the URI. Queries always start with a question mark and must be url- encoded. No message body is sent along with a GET request.

POST Method
The POST method is another example of a request method. The POST method is used to add or modify a resource according to the message body of the request, on the host specified in the URI of the request. The message body contains the information used to create or update a resource on the website.
_   POST requests are often used by HTML forms to submit data. If the data in the message body is from an HTML form, then like a GET query, it is url- encoded.

PUT Method
The PUT method is another example of a request method. The PUT method takes the information provided in the body of the request, and creates or updates a resource at the location specified in the URI of the request. The URI specified in the request dictates to the server the identity and location of the enclosed resource.
_   The PUT method can be used to create or update a resource, like the POST method. The information contained in the request body of a POST method, however, is created or updated under an identity and location determined by the web server, which is not necessarily the identity and location in the supplied URI.

HTTP Statelessness
HTTP can also be stateless. This means that the relationship between requests is not preserved.
_   For example, if a user were browsing an online shopping website, and clicking different items, the HTTP protocol does not keep track of which items have been previously clicked. Every time a new item is clicked, a new request is sent, but the protocol is unaware if the same client is making the request.
_   HTTP cookies can be used by websites to track the behaviour of users on the site. When a client makes a request, the site gives an HTTP cookie to store information about the user’s browsing session. The cookie is stored by the client, and updated by the server each time the client makes a request to the server. This allows the server to store state information about interactions with a particular client, which can be useful for tracking purposes.
_   HTTP is fundamental for the web, as it dictates how data is communicated and exchanged. This makes HTTP very important for invoking and accessing web services, and enabling a service-oriented architecture.

4.1.7 – JavaScript
Javascript is a programming language that can be used for a variety of purposes. Javascript is able to modify elements, attributes, styles, and content within the HTML document. Javascript can be embedded between “script” tags in HTML (<script></script>).
_   Javascript is able to provide interactive elements to web pages, because it is an interpreted language. This means that Javascript code is interpreted by a web browser at run time. In other words, embedded Javascript is a series of commands that are executed by the web browser when it loads the HTML document.
_   It is possible for web pages to provide some interaction to users without Javascript, through the use of HTML forms that submit POST or GET requests. The web server responds to the request by providing the web browser with a new HTML document. The result of the interaction will be visible only after the browser has received and loaded the new HTML document. However, interactions provided to users on a web page embedded with Javascript tend to be more efficient and more usable. With Javascript, a form can be partly checked and processed on the client-side. This means that the browser does not have to wait for the web server to provide a new page, instead, the Javascript on the page can dynamically change the HTML web page that is already loaded in the browser as it runs the client- side in the browser. This offloads some of the processing required to operate this application so that not everything needs to be processed server-side.
_   Javascript is able to modify elements on a web page by making use of the HTML Document Object Model (DOM). When a page is loaded in a web browser, the HTML document becomes a document object. This object can be used by Javascript to obtain and modify the elements and content on the web page. As a result of processing the document object, the content, structure, and style of an HTML document can be modified.
_   








































