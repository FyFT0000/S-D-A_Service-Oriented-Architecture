https://www.coursera.org/learn/service-oriented-architecture?specialization=software-design-architecture

Service-Oriented Architecture
    Based on an understanding of architectural styles, you will review architectures for web applications, then explore the basics of Service-Oriented Architecture (SOA) in two approaches: Web Services (WS*) and Representational State Transfer (REST) architecture. 



4.1.1 – Introduction to Service-Oriented Architecture
A service is external to the software requesting it, and often remove – either in another service in the company or somewhere on the internet. Services are often associated with two roles:
    _1. the service requester, which is the software requesting the service.
    _2. the service provider, which fulfills requests.
 These roles echo client and server roles in similar domains, so sometimes these terms are used interchangeably.
 _   Service-Oriented Architecture (SOA): examines how to build, use, and combine services. Instead of creating large software suites that do everything, service-oriented architecture reaches software goals by building and using services, and designing an architecture that supports their use. This course will cover software-oriented architecture in two contexts:
    _1. on the Internet (also known as “external” to an organization)
    _2. in large organizations (also known as “internal” to the organization)
_   Web Services: are services that are offered on the Internet. It is possible to build feature-full apps on the Internet by using existing web services external to your application to fulfill some of the tasks. For instance, a web application for travelling may take advantage of services that obtain flight prices on the internet, services that obtain hotel prices, or car rental services. Essentially, a number of services only had to be combined to create an application.
    _Web services may entail trade-offs. The ease of using existing services must be balanced against qualities of the services, which is not under the control of developers. In these cases, non-functional requirements become very important. These might include:  Response Time  Supportability  Availability, of the service, as determined by outside parties.
_   Large Organizations or enterprises: code that is built in-house can be turned into services. In turn, these services can be used by different parts of the business, or by adding interfaces to existing software. These services can then be used to drive business or organizational goals. For example, a company might offer an interface for software systems in various departments to request information about support costs in their software. Support costs are offered as a service that departments can query.
    _Internal service-oriented architecture encourages organizations to build general, reusable software services that can be used and combined as needed. This architecture allows businesses to respond to opportunities quickly, and makes services easier to access for new business units.
    _Developing an extensive service-oriented architecture (SOA) can present trade-offs for large organizations. A full switch to SOA is costly, and it can be difficult to support despite its benefits. In these cases, services are often introduced bit by bit, separating out the most useful, cross-departmental functions first.
    _Like any other architecture, SOA requires trade-offs and design decisions in implementation, whether it is through web services or in-house organizational services. Additionally, SOA is not easy. Once in place, however, SOAs are powerful, as they provide modularity, extensibility, and code reuse. Applications can be built through combining services. New services can be created by combining existing services, either from the ground up, or through the addition of interfaces to existing code.

4.1.2 – Service Principles
In order to create useful and reusable services, and by extension, service-oriented architecture (SOA), there are certain best practices, guidelines, and principles that have been developed that outline the desired properties that services should have. These desired properties for services are outlined in the table below.
_   Modular and Loosely Coupled: Services should be module and loosely coupled. This allows services to be reusable and combinable – in other words, services can be mixed and matched if they are modular. In object-oriented programming, loose coupling is achieved by exposing only the relevant elements of a class or component to its client. In SOA, requests are made by passing communication to the service in a way that aligns with its interface. The service performs the necessary operations and then passes back a communication containing the result of the service or a confirmation that the request was fulfilled.
_   Composable: Services should be used in combination, in order to create usable applications or other services. In order to achieve this property, services should be modular. Just like objects can be combined in object-oriented programming to provide the desired behaviour, services should be able to combined to provide a desired end- goal in SOA.
_   Platform- and Language- Independent: Services should be platform independent and language independent. For example, a service coded in Java can be used by a service requester coded in Ruby. To achieve platform- and language- independence, communication standards and protocols must be followed. For example, services on the Internet are often requested with an XML file or HTTP request.
_   Self-Describing: A service should describe how to interact with it. In other words, a service should describe its own interfaces. This includes what input the service takes, and what output the service gives. There are formal standards for describing services, including web service description language (WSDL).
_   Self-Advertising: Services must make known to potential clients that it is available. In-house organizations may create service catalogues, while distributed applications using web services have standards like Universal Description, Discovery, and Integration (UDDI) to connect service providers with potential service requesters.

4.1.3 - Web Systems Evolution
Often, the terms “Internet” and “World Wide Web” are used interchangeable. However, these terms actually refer to two different, but interrelated things. The Internet was actually invented almost 20 years before the World Wide Web!
_   In 1969, a small computer network called ARPANET was created and used by researchers in the United States, in order to send a small amount of data between pairs of computers. This was the first-time data was sent across a computer network. In the following years, small networks were developed at research institutions across the United States. Further, these networks began to connect with each other. Once this network of networks reached a global scale, the Internet was born.
_   The World Wide Web, otherwise known as “the web” led to standards and technologies for computer-based communication over the Internet. Web standards include Hypertext Markup Language (HTML), and Hypertext Transport Protocol (HTTP). The introduction of HTML and web browsers in the early 1990s, which allowed users to view websites, greatly increased the popularity of the web.
_   Websites are made up of web pages. To view a web page, the web browser makes a request to the web server that hosts the web page, then the web server handles the request by returning the HTML document that corresponds to the requested web page, and then the browser renders this HTML document to the user. The relationship between web browser and web service is a client-server relationship. Both the request and the response are messages conveyed in HTTP, a communication protocol that both the web browser and web server understand.
_   Static Web Pages: Initially, the web consisted of static web pages, which were web pages stored on the server as a separate HTML file. When a static web page is viewed on a web browser, the HTML rendered on the screen is the same HTML document stored on the web server. The document on the web server has not changed or been customized before being served to the client. In order to change the web page, the corresponding HTML document must be changed. Under this model, even small changes to a web page may require the update of many HTML documents to maintain consistency across the whole website. Since changes require manual developer intervention, static websites are best used for presenting information that does not change very often, like personal websites or publications.
_   Dynamic Web Pages: Beginning in 1993, dynamic web pages began to emerge in response to the lack of customizability and scalability imposed by static web pages. Dynamic web pages are generated at the time of access. This means that the web page does not exist on a server before it is generated. When a dynamic web page is viewed, the web server passes on the request to an application to handle. The application can perform a computation, lookup some information in a database, or request information from a web service, which produces dynamic content as output. The application can generate an HTML document for the server, and then the server sends that back to the web browser, which can then display it for a user.
    _Making changes to dynamic websites is much easier than for static web pages. Changes need only be applied to one database element or variable in the application to make a change throughout a dynamic website.
    _Dynamic web pages provide many advantages. They can be customized for the view, they can respond to external events, they generally provide increased functionality compared to their static counterparts, and they are easier for a developer to modify. Currently, dynamic web pages dominate the web, including many types of webpages such as personal blogs and news feeds.
    _Although it is not always easy to determine if a website is statically or dynamically generated, a good rule of thumb is that more complex websites tend to be dynamic. Static webpages are still excellent tools to use for web pages whose content does not need to be personalized or does not change often.
_   Web Applications: A growing trend in web-based systems is the use of web-based applications, otherwise known as web applications. Web applications, like desktop applications, provide graphical user interfaces that allow users to interact with them, but a web application is run in a web browser and is stored on a remote web server, whereas a desktop application is run and stored locally on a computer.
    _Web applications are platform independent. This means that they can run on any operating system, provided that a compatible web browser is installed. Web applications eliminate the need for users to download and maintain application software on a computer. However, web applications also require users to have Internet access, because web applications communicate information through HTTP with a web server and/or application server on the backend.
    _Web applications provide users with a richer, more interactive web experience than simpler dynamic or static web pages. Web applications enable everything from online banking, online learning, online games, calculators, calendars, and more.
_   Web Services: If web applications or websites integrate with web services, real-time information can be used to create more complex, richer applications. Web services, in turn, can rely on other services. Web services can be used to satisfy specific needs, such as stock market data, weather reports, or currency conversion.
    _By treating web services like reusable components, information produced by these web services can be used by many different web applications at the same time. Web applications and web services communicate over the web using open standards like HTTP, XML, and JSON, which are easy for machines to manipulate.
    _Web services can be accessed through programmatic means, or services provide a user interface that can be embedded in a web page or application. By using web services, request and response of different services is asynchronous. This means that the logic is designed to continue running instead of waiting for a response. A page composed of many services can be generated while the individual services are processing requests and sending responses.

4.1.4 – Web Systems Architecture

Layered: 
In the third course of this specialization, the term layer was defined as a collection of components that work together toward a common purpose. Layers help identify hierarchies in a system. Knowledge of layers helps software designers restrict how layers interact with each other: components in a layer only interact with components in their own layer or adjacent layers, and this may only be done through interfaces provided by each component. Generally, lower layers provide services to layers above them.
_   More complex systems often require more layers to help logically separate components. However, the trade-off to adding more layers is that performance suffers, due to an increase in communication required between layers. Layers are often conceptually organized into presentation, application, and data tiers. In a web-based system, the presentation tier is further divided into two layers: one for the web browser, and one for the web server.
_   Each layer of a web-based system has a function:
    _The web browser layer is the topmost layer of the system. It displays information to the user.
    _The web server layer is directly below the web browser layer. It receives the request from the web browser, obtains the requested content, and returns it to the browser.
    _The application layer is below the web server layer. It is responsible for ensuring the function or service provided by the system is performed.
    _The bottom layer is the data layer. This layer is responsible for storing, maintaining, and managing data. Access to data may be read-only, or may allow for both reading and writing. Depending on the system, this access can be in the form of a filesystem or database.

Layers for Static Web Content:
A static web page has a layered architecture of a web browser layer, a web server layer, and a data layer.
_   The web browser layer typically consists of a web browser, which displays information provided by the web server. The web server layer receives the request from the web browser, and retrieves the appropriate HTML document stored in the data layer. Once the access to the right HTML document is secured, this layer returns the requested content to the browser.
_   The data layer consists of HTML documents that are delivered back to the web browser unchanged by the web server. As HTML documents do not change, the filesystem can be read-only.
_   There is no application layer in a static web content system, as the HTML documents served by the web server are the exact as stored in the file system. No processing has been applied.

Layers for Dynamic Web Content and Web Applications:
In a dynamic web content system, a layered architecture requires a web browser layer, web server layer, application layer, and data layer.
_   As with static web content, the web browser layer typically consists of a web browser, which displays information provided by the web server. Similarly, the web server layer receives the request from the web browser, and returns the requested content to the browser. Unlike a static web page, however, on a dynamic web page, HTML documents are generated when they are requested by a web browser. The web server passes on the request to an application server in the application layer for processing.
_   The application layer for dynamic web pages can consist of one or more programs or applications that process the request to generate the resulting content. The application layer may also call upon other web services, and read and write data to a database via the data layer. This same layering scheme also applies to architectures for complex web applications.

Services View:
An alternative view of the architecture can be considered through a UML component diagram. A web-based system can be thought of as a collection of services and service requester/provider pairings.
_   For example, the database provides data services, and the application server is a server requester to the database. The application server runs programs that may access a variety of web services provided outside the system. Those web services may themselves access other services.
_   Layered architecture and use of outside web services reinforces the basic design principles of separation of concerns and code reuse. Layers have specific responsibilities, while outside services provide functionality that the system does not have to implement. The scope of using web services is huge, so it raises the challenge of identifying the right ones to use.

































